<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="documentation" />
    <title>Publish.jl</title>
    <link rel="stylesheet" href="..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;publish.css" />
    <link rel="stylesheet" href="..&#x2F;default.min.css" />
    <script src="..&#x2F;versions.js"></script>
    <script src="..&#x2F;lunr.js"></script>
    <script src="..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;publish.js"></script>
    
</head>
<body>
    <div class="menu">
        <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        <input id="search-input" placeholder="Search">
        <select id="version-selector"></select>
    </div>
    <main id="page"><article><h1 id="output-formats"><a href="#output-formats" class="anchor"></a>Output Formats</h1>
<p>“Targets” represent different ways to output <a href="../docstrings/Publish.Project.html"><code>Project</code></a> objects.  This
might be as a literal file or tree of files, or it may be test results from
running doctests, or perhaps checking validity of external links.</p>
<pre><code class="language-julia">writer(f, p::Project, temp::AbstractString) = f(p, temp)

html(p::Project, changed, temp) = writer(html, p, temp)
search(p::Project, changed, temp) = writer(search, p, temp)
pdf(p::Project, changed, temp) = writer(pdf, p, temp)
test(p::Project, changed, temp) = writer(test, p, temp)

&quot;&quot;&quot;
    html(source, [dir])

Write `source` to HTML format. `dir` optionally provides the directory to write
the final content to. When this directory is not provided then a temporary
directory is used.
&quot;&quot;&quot;
function html(source, temp=nothing)
    p = from_source(source)
    sandbox(temp) do
        # Clean up the index.html since we check it's existance for redirect page.
        rm(&quot;index.html&quot;; force=true)
        # Copy over resources that are important to this target type.
        suitable_mimes = map(MIME, (&quot;text/html&quot;, &quot;text/javascript&quot;, &quot;text/css&quot;))
        write_resources(p, suitable_mimes)
        # Write all the pages out to html.
        toc_root = tocroot(p)
        # Define the page ordering. We partition the order so that we have
        # access to each page's previous and next siblings for use in page
        # navigation. For this we need a `fake` page at the start and end of
        # our document.
        fake = Ref(nothing =&gt; nothing)
        order = Iterators.flatten((fake, p.pages, p.docs, fake))
        for ((prev, _), (path, page), (next,_)) in IterTools.partition(order, 3, 1)
            rpath = relpath(path, toc_root)
            rdir = dirname(rpath)
            isdir(rdir) || mkpath(rdir)
            name, _ = splitext(rpath)
            html_file = name * &quot;.html&quot;
            # Calculate the previous and next page URLs.
            if prev !== nothing
                name, _ = splitext(relpath(prev, dirname(path)))
                p.env[&quot;publish&quot;][&quot;html&quot;][&quot;prev&quot;] = &quot;$name.html&quot;
            end
            if next !== nothing
                name, _ = splitext(relpath(next, dirname(path)))
                p.env[&quot;publish&quot;][&quot;html&quot;][&quot;next&quot;] = &quot;$name.html&quot;
            end
            # Calculate the table of contents for this page.
            p.env[&quot;publish&quot;][&quot;html&quot;][&quot;toc&quot;] = build_html_toc(p, path)
            # Activate smart linking relative to the current `html_file`.
            p.env[&quot;publish&quot;][&quot;smartlink-engine&quot;] = (mime, obj, node, env) -&gt; smartlink(mime, obj, node, env, p, html_file, page)
            relative_paths(p, p.env[&quot;publish&quot;], html_file) do pub
                open(html_file, &quot;w&quot;) do handle
                    fm = frontmatter(page.node)
                    pub = isempty(fm) ? pub : CommonMark.recursive_merge(pub, fm)
                    CommonMark.html(handle, page.node, pub)
                end
            end
            # Delete previous and next pages.
            delete!(p.env[&quot;publish&quot;][&quot;html&quot;], &quot;prev&quot;)
            delete!(p.env[&quot;publish&quot;][&quot;html&quot;], &quot;next&quot;)
        end
        # Generate a fake index.html page that redirects to the first page in the p.pages dict.
        if !isfile(&quot;index.html&quot;) &amp;&amp; !isempty(p.pages)
            path, _ = first(p.pages)
            rpath = relpath(path, toc_root)
            name, _ = splitext(rpath)
            content = &quot;&quot;&quot;
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;&lt;head&gt;&lt;meta http-equiv = &quot;refresh&quot; content = &quot;0; url = $name.html&quot; /&gt;&lt;/head&gt;&lt;/html&gt;
            &quot;&quot;&quot;
            write(&quot;index.html&quot;, content)
        end
        # Build the search page, overwrites any search.html already written.
        html_file = &quot;search.html&quot;
        p.env[&quot;publish&quot;][&quot;html&quot;][&quot;toc&quot;] = build_html_toc(p, joinpath(p.project.name))
        relative_paths(p, p.env[&quot;publish&quot;], html_file) do pub
            open(html_file, &quot;w&quot;) do handle
                node = load_markdown(IOBuffer(&quot;# Search\n&lt;div id='search-results'&gt;&lt;/div&gt;&quot;))
                CommonMark.html(handle, node, pub)
            end
        end
        # Write the search data to file.
        search(p, pwd())
        # Build a basic versions.js file, this is overwritten by `deploy`.
        open(&quot;versions.js&quot;, &quot;w&quot;) do handle
            println(handle, &quot;const PUBLISH_ROOT = '';&quot;)
            println(handle, &quot;const PUBLISH_VERSION = null;&quot;)
            println(handle, &quot;const PUBLISH_VERSIONS = [];&quot;)
        end
        # Remove the generated table of contents string.
        delete!(p.env[&quot;publish&quot;][&quot;html&quot;], &quot;toc&quot;)
    end
    return source
end
</code></pre>
<h2 id="smart-link-implementation"><a href="#smart-link-implementation" class="anchor"></a>“Smart” Link Implementation</h2>
<p>First some helper methods for looking up the <code>Binding</code> object of a value.</p>
<pre><code class="language-julia">function binding(mod::Module, expr::Expr)
    if Meta.isexpr(expr, :.)
        parent = binding(mod, expr.args[1])
        if Docs.defined(parent)
            return binding(Docs.resolve(parent), expr.args[2:end]...)
        end
    end
    return Docs.Binding(mod, nameof(mod))
end
binding(mod::Module, str::AbstractString) = binding(mod, Meta.parse(str; raise=false))
binding(mod::Module, symbol::Symbol) = Docs.Binding(mod, symbol)
binding(mod::Module, quot::QuoteNode) = Docs.Binding(mod, quot.value)
binding(mod, other...) = Docs.Binding(mod, nameof(mod))
binding(str::AbstractString) = binding(Main, str)
binding(mod::Module) = binding(mod, nameof(mod))
</code></pre>
<p>“Smart” link cross-referencing.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    smartlink(mime, obj, node, env, p, html_file, page)

Generate a cross-reference link.
&quot;&quot;&quot;
function smartlink(
    ::MIME&quot;text/html&quot;,
    obj::CommonMark.Link,
    node::CommonMark.Node,
    env,
    p::Project,
    html_file::AbstractString,
    page
)
    if obj.destination == &quot;#&quot;
        # The following closures are used in multiple branches and so are
        # defined above to avoid repetition.
        function docs_func!(literal::AbstractString)
            dict = page.dict === nothing ? Dict() : page.dict
            module_binding = binding(get(dict, &quot;module&quot;, project_to_module(p.env)))
            if Docs.defined(module_binding)
                target_binding = binding(Docs.resolve(module_binding), literal)
                if Docs.defined(target_binding)
                    obj = deepcopy(obj)
                    rel = relpath(&quot;docstrings/$target_binding.html&quot;, dirname(html_file))
                    obj.destination = rel
                    @goto END
                end
            end
            @warn &quot;cross-reference link '$literal' on page '$html_file' cound not be found.&quot;
            @label END
            return nothing
        end
        function header_func!(literal::AbstractString)
            toc_dir = joinpath(dirname(p.project.name), dirname(p.env[&quot;publish&quot;][&quot;toc&quot;]))
            slug = CommonMark.slugify(literal)
            for (path, page) in p.pages, (node, enter) in page.node
                if enter &amp;&amp; get(node.meta, &quot;id&quot;, nothing) == slug
                    name, _ = splitext(relpath(relpath(path, toc_dir), dirname(html_file)))
                    obj = deepcopy(obj)
                    obj.destination = &quot;$name.html#$slug&quot;
                    obj.title = &quot;&quot;
                    @goto END
                end
            end
            @warn &quot;cross-reference link '$literal' on page '$html_file' could not be found.&quot;
            @label END
            return nothing
        end
        # `#` is used for cross-references. The link is determined by either
        # the provided `.title` field of the link, or the contents of the link.
        if isempty(obj.title)
            # No title provided so we use the contents of the link.
            (!CommonMark.isnull(node.first_child) &amp;&amp; node.first_child.t isa CommonMark.Code) ?
                docs_func!(node.first_child.literal) : header_func!(node.first_child.literal)
        else
            # The `.title` is available, so use that to determine the link.
            m = match(r&quot;^`(.+)`$&quot;, obj.title)
            m === nothing ? header_func!(obj.title) : docs_func!(m[1])
        end
        return obj
    elseif startswith(obj.destination, '#')
        # Ignore bare anchor links.
        return obj
    else
        # Links that aren't cross-references are either left as is, or adjusted
        # to point at the generated `.html` file rather than the original
        # source file.
        uri = parse(HTTP.URIs.URI, obj.destination)
        uri.scheme == &quot;&quot; || return obj
        # Only try local URLs.
        obj = deepcopy(obj)
        if get(env, &quot;#toc&quot;, false)
</code></pre>
<p>Adjust paths due to inclusion of a toc, which has a different path.</p>
<pre><code class="language-julia">            rpath = joinpath(&quot;.&quot;, relpath(html_file, tocroot(p)))
            name, _ = splitext(relpath(obj.destination, dirname(rpath)))
            obj.destination = &quot;$name.html&quot;
        else
            name, _ = splitext(obj.destination)
            obj.destination = &quot;$name.html&quot;
        end
        return obj
    end
end
smartlink(mime, obj, node, env, p, html_file, page) = obj
</code></pre>
<p>And some other helpers needed for <a href="../docstrings/Publish.html.html"><code>html</code></a> generation.</p>
<pre><code class="language-julia">function build_html_toc(p::Project, path::AbstractString)
    fn = (mime, obj, node, env) -&gt; smartlink(mime, obj, node, env, p, path, nothing)
    return CommonMark.html(p.env[&quot;_toc&quot;].node, Dict(&quot;smartlink-engine&quot; =&gt; fn, &quot;#toc&quot; =&gt; true))
end

function relative_paths(f, p::Project, pub::AbstractDict, file::AbstractString)
    root = dirname(p.project.name)
    file_dir = dirname(joinpath(&quot;.&quot;, file))
    temp_pub = with_replacement(pub) do value
        if value in DEFAULT_ASSETS_SET
            # Default resources are set relative to the `src/templates`
            # directory.  which 'mirrors' the project root directory. Resources
            # with the same names that the user provides will get overwritten.
            rpath = relpath(value, joinpath(@__DIR__, &quot;templates&quot;))
            return relpath(rpath, file_dir)
        elseif isabspath(value) &amp;&amp; isfile(value)
            # Handles template files.
            return value
        else
            path = joinpath(root, value)
            return _isfile(path) ? relpath(value, file_dir) : value
        end
    end
    f(temp_pub)
end

_isfile(s::AbstractString) = length(s) ≤ 144 &amp;&amp; isfile(s) # TODO: hack for ENAMETOOLONG.

with_replacement(f, value) = value
with_replacement(f, value::AbstractString) = f(value)
with_replacement(f, vec::Vector{T}) where T = T[with_replacement(f, elem) for elem in vec]
with_replacement(f, dict::T) where T &lt;: AbstractDict = T(k =&gt; with_replacement(f, v) for (k, v) in dict)

from_source(p::Project) = p
from_source(m::Module) = Project(m)
from_source(s::AbstractString) = Project(s)
</code></pre>
<h2 id="json-search-data-target"><a href="#json-search-data-target" class="anchor"></a>JSON Search Data Target</h2>
<pre><code class="language-julia">function search(source, temp=nothing)
    p = from_source(source)
    dict = Dict{String,String}()
    root = tocroot(p)
    for (path, page) in Iterators.flatten((p.pages, p.docs))
        path = relpath(path, root)
        name, _ = splitext(path)
        path = &quot;$name.html&quot;
        id = path
        for (node, enter) in page.node
            if enter
                if haskey(node.meta, &quot;id&quot;)
                    id = &quot;$path#$(node.meta[&quot;id&quot;])&quot;
                end
                if (node.t isa CommonMark.Text || node.t isa CommonMark.Code)
                    if haskey(dict, id)
                        dict[id] = &quot;$(dict[id]) $(node.literal)&quot;
                    else
                        dict[id] = node.literal
                    end
                end
            end
        end
    end
    json = Dict{String,String}[]
    for (id, body) in dict
        push!(json, Dict(&quot;id&quot; =&gt; id, &quot;body&quot; =&gt; body))
    end
    sandbox(temp) do
        write(&quot;search.json&quot;, JSON.json(json))
    end
    return source
end
</code></pre>
<h2 id="pdf-generation"><a href="#pdf-generation" class="anchor"></a>PDF generation.</h2>
<p>Our PDF creation uses a LaTeX engine, in the form of <em>tectonic</em>, to make PDF output.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    pdf(source, [dir])

Write `source` project to PDF format. `dir` may optionally specify the
directory to write the finished document to. Intermediate `.tex` files are
retained for debugging purposes.
&quot;&quot;&quot;
function pdf(source, temp=nothing)
    p = from_source(source)
    sandbox(temp) do
        toc_root = tocroot(p)
        # Write pages to separate document and include it in main tex document.
        includes = IOBuffer()
        println(includes, &quot;```{=latex}&quot;)
        for (path, page) in p.pages
            rpath = relpath(path, toc_root)
            name, _ = splitext(rpath)
            name = unix_style_path(name) # Path adjustments for Windows.
            println(includes, &quot;\\include{$name}&quot;)
            out = tex(name)
            dir = dirname(out)
            isdir(dir) || mkpath(dir)
            open(out, &quot;w&quot;) do handle
                CommonMark.latex(handle, page.node)
            end
        end
        println(includes, &quot;```&quot;)
        parser = CommonMark.enable!(CommonMark.Parser(), CommonMark.RawContentRule())
        ast = load_markdown(includes, parser)
        project_file = tex(p.env[&quot;name&quot;])
        open(project_file, &quot;w&quot;) do handle
            CommonMark.latex(handle, ast, p.env[&quot;publish&quot;])
        end
        # Build the final PDF document using tectonic.
        Tectonic.tectonic() do path
            run(`$path $project_file`)
        end
    end
    return source
end

# Needed by latex engine since it doesn't like windows paths.
if Sys.iswindows()
    unix_style_path(path) = unix_joinpath(splitpath(path)...)
else
    unix_style_path(path) = path
end
function unix_joinpath(path::AbstractString, paths::AbstractString...)::String
    for p in paths
        if isabspath(p)
            path = p
        elseif isempty(path) || path[end] == '/'
            path *= p
        else
            path *= &quot;/&quot; * p
        end
    end
    return path
end
unix_joinpath(path::AbstractString) = path
</code></pre>
<h2 id="doctests-stub"><a href="#doctests-stub" class="anchor"></a>“Doctests” Stub</h2>
<p>This is not implemented yet. Output should be the same as for the <code>Test</code>
module. Probably use it to do the actual testing.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    test(source)

Run all doctests defined within project `source`.
&quot;&quot;&quot;
function test(source, temp=nothing)
    p = from_source(source)
    sandbox(temp) do
        for (path, page) in p.pages, (node, enter) in page.node
            if enter &amp;&amp; isdoctest(node)
                # TODO: do testing here.
            end
        end
    end
    return source
end
</code></pre>
<h2 id="live-server"><a href="#live-server" class="anchor"></a>Live Server</h2>
<p>Used to do iterative editing by avoiding the edit-compile-read-loop.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    serve(source, [targets...])

Start watching the project defined by `source` for changes and rebuild it when
any occur. `targets` lists the functions to run when any changes take place. By
default this is [`html`](#), which runs a background HTTP server that presents
the generated HTML output at `localhost:8000`.
&quot;&quot;&quot;
function serve(source, targets...=html; kws...)
    p = from_source(source)
    w = WatchedProject(p, targets...)
    try
        for target in targets
            target(w; kws...)
        end
    finally
        wait() # Wait until all tasks done.
        stop(w)
    end
    return source
end

function html(w::WatchedProject; port=8000, kws...)
    dir = w.dirs[html]
    html(w.p, dir)
    @async LiveServer.serve(; dir=dir, port=port)
end

function search(w::WatchedProject; kws...)
    if haskey(w.dirs, html)
        # Search data is written to the HTML directory.
        dir = w.dirs[html]
        search(w.p, dir)
    end
end

function pdf(w::WatchedProject; kws...)
    dir = w.dirs[pdf]
    pdf(w.p, dir)
    file = joinpath(dir, w.p.env[&quot;name&quot;] * &quot;.pdf&quot;)
    run(`$PDF_VIEWER $file`; wait=false)
end
</code></pre>
<h2 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h2>
<pre><code class="language-julia">const PDF_VIEWER = Sys.iswindows() ? &quot;start&quot; : Sys.isapple() ? &quot;open&quot; : &quot;xdg-open&quot;

isdoctest(n) = n.t isa CommonMark.CodeBlock &amp;&amp; n.t.info == &quot;jldoctest&quot;

function write_resources(p::Project, mimes)
    project_root = projectroot(p)
    assets_root = joinpath(@__DIR__, &quot;templates&quot;)
    for (path, file) in p.resources
        rpath = relpath(path, path in DEFAULT_ASSETS_SET ? assets_root : project_root)
        dir = dirname(rpath)
        if file.text !== nothing &amp;&amp; file.mime in mimes
            isdir(dir) || mkpath(dir)
            write(rpath, file.text)
        end
    end
end

sandbox(f, ::Nothing) = mktempdir(dir -&gt; cd(f, dir))
sandbox(f, temp::AbstractString) = isdir(temp) ? cd(f, temp) : (mkpath(temp); cd(f, temp))

tocroot(p::Project) = abspath(joinpath(dirname(p.project.name), dirname(p.env[&quot;publish&quot;][&quot;toc&quot;])))
projectroot(p::Project) = abspath(dirname(p.project.name))
tex(filename::AbstractString) = filename * &quot;.tex&quot;
</code></pre>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="projects.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="docstrings.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
    </main>
    <nav id="toc"><p style="text-align: center"><strong>MANUAL</strong></p>
<ol style="margin: 0 auto; max-width: 350px">
<li><a href="../README.html">Introduction</a></li>
<li><a href="../docs/getting_started.html">Getting Started</a></li>
<li><a href="../docs/structure.html">Project Structure</a></li>
<li><a href="../docs/references.html">Cross Referencing</a></li>
<li><a href="../docs/config.html">Configuration</a></li>
<li><a href="../docs/templates.html">Templates</a></li>
<li><a href="../docs/sources.html">Source Types</a></li>
<li><a href="../docs/syntax.html">Markdown Syntax</a></li>
</ol>
<p style="text-align: center"><strong>Examples</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="../examples/basics.html">Basics</a></li>
</ul>
<p style="text-align: center"><a href="../docstrings.html"><strong>LIBRARY INDEX</strong></a></p>
<p style="text-align: center"><strong>SOURCE</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="Publish.html">Publish.jl</a></li>
<li><a href="files.html">files.jl</a></li>
<li><a href="projects.html">projects.jl</a></li>
<li><a href="targets.html">targets.jl</a></li>
<li><a href="docstrings.html">docstrings.jl</a></li>
<li><a href="tools.html">tools.jl</a></li>
</ul>
<p style="text-align: center"><a href="../LICENSE.html"><strong>LICENSE</strong></a></p>
</nav>
    <footer>
        Build with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language.</a>
    </footer>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
