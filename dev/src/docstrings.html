<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="documentation" />
    <title>Publish.jl</title>
    <link rel="stylesheet" href="..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;publish.css" />
    <link rel="stylesheet" href="..&#x2F;default.min.css" />
    <script src="..&#x2F;versions.js"></script>
    <script src="..&#x2F;lunr.js"></script>
    <script src="..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;publish.js"></script>
    
</head>
<body>
    <div class="menu">
        <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        <input id="search-input" placeholder="Search">
        <select id="version-selector"></select>
    </div>
    <main id="page"><article><h1 id="interface-for-julias-docsystem"><a href="#interface-for-julias-docsystem" class="anchor"></a>Interface for Julia’s Docsystem</h1>
<p>Not much is needed from the docsystem, we just build each <code>Binding</code>’s
docstrings as separate pages, as well as a table with links to each docstring
page. There’s no concept of <code>@docs</code> and <code>@autodocs</code> found in Documenter.jl.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    docstrings(p)

Extract all available docstrings for given `Project` `p` and return a
`files::Dict` containing a mapping from absolute path to `File` object and an
`index` object, which is [`File`](#) object containing a formatted table of all
docstrings with information on `name`, `module`, `visibility`, and `category`
of each docstring.
&quot;&quot;&quot;
function docstrings(p::Project)
    toc_root = dirname(joinpath(dirname(p.project.name), p.env[&quot;publish&quot;][&quot;toc&quot;]))
    docstring_dir = joinpath(toc_root, &quot;docstrings&quot;)
    mod = project_to_module(p.env)
    files = Pair{String,File}[]
    table = IOBuffer()
    println(table, &quot;{#docstring-index}&quot;)
    println(table, &quot;| Name | Module | Visibility | Category |&quot;)
    println(table, &quot;|:---- |:------:|:----------:| --------:|&quot;)
    for each in p.mods
        root = rootmodule(each)
        if root === mod
            for (k, v) in Docs.meta(each)
                object_name = string(k.var)
                module_name = string(k.mod)
                visibility = Base.isexported(k.mod, k.var) ? &quot;public&quot; : &quot;private&quot;
                category = categorise(k)
                # Write the docstring file, may concatenate several similar
                # docstrings -- those with the same name, but different
                # signatures.
                filename = joinpath(docstring_dir, &quot;$k.md&quot;)
                io = IOBuffer()
                println(io, &quot;```{=html}\n&lt;div class='docs' id='$(k.var)'&gt;\n```&quot;)
                println(io, &quot;*`$visibility`* **`$object_name`** --- `$category`\n&quot;)
                for (n, sig) in enumerate(v.order)
                    println(io, &quot;```{=html}\n&lt;div class='doc' id='$n'&gt;\n```&quot;)
                    println
                    doc = v.docs[sig]
                    println(io)
                    printdoc(io, doc)
                    println(io)
                    println(io, &quot;```{=html}\n&lt;/div&gt;\n```&quot;)
                end
                println(io, &quot;```{=html}\n&lt;/div&gt;\n```&quot;)
                file = File(
                    name = filename,
                    mime = MIMETYPES[&quot;.md&quot;],
                    node = load_markdown(io),
                    dict = Dict(&quot;module&quot; =&gt; each),
                )
                push!(files, filename =&gt; file)
                # Add an entry to the table index for this name.
                println(table, &quot;| [`$object_name`](docstrings/$(k).html) | `$module_name` | `$visibility` | `$category` |&quot;)
            end
        end
    end
    sort!(files; by=first)
    index = File(
        name = joinpath(toc_root, &quot;docstrings.md&quot;),
        mime = MIMETYPES[&quot;.md&quot;],
        node = load_markdown(table),
    )
    docs = OrderedDict{String,File}()
    docs[index.name] = index
    for (path, file) in files
        docs[path] = file
    end
    return docs
end
</code></pre>
<h2 id="helpers"><a href="#helpers" class="anchor"></a>Helpers</h2>
<pre><code class="language-julia">&quot;&quot;&quot;
    printdoc(io, docstr)

This method prints out the parts of an individual `Docs.DocStr` object to the
given `IO` object `io`. It is used to get the &quot;formatted&quot; content of the
docstring without it being pre-parsed by the `Markdown` standard library.
&quot;&quot;&quot;
function printdoc(io::IO, docstr)
    for part in docstr.text
        Docs.formatdoc(io, docstr, part)
    end
    return io
end

&quot;&quot;&quot;
    rootmodule(m)

The &quot;root&quot; module of a given `Module` `m`.
&quot;&quot;&quot;
rootmodule(m::Module) = (p = parentmodule(m); p === m ? m : rootmodule(p))

&quot;&quot;&quot;
    categorise(binding)

For the given `Docs.Binding` object, determine and return its &quot;category&quot;,
namely either &quot;constant&quot;, &quot;global&quot;, &quot;struct&quot;, &quot;type&quot;, &quot;parametric struct&quot;,
&quot;parametric type&quot;, &quot;module&quot;, &quot;macro&quot;, or &quot;function.
&quot;&quot;&quot;
function categorise(binding)
    # Helpers.
    ismacro(binding) = startswith(string(binding.var), '@')
    # Categoriser.
    category(other)         = isconst(binding.mod, binding.var) ? &quot;constant&quot; : &quot;global&quot;
    category(obj::Module)   = &quot;module&quot;
    category(obj::DataType) = isconcretetype(obj) ? &quot;struct&quot; : &quot;type&quot;
    category(obj::UnionAll) = isconcretetype(obj) ? &quot;parametric struct&quot; : &quot;parametric type&quot;
    category(obj::Function) = ismacro(binding) ? &quot;macro&quot; : &quot;function&quot;

    if Docs.defined(binding)
        object = Docs.resolve(binding)
        return category(object)
    else
        return &quot;undefined&quot;
    end
end
</code></pre>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="targets.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="tools.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
    </main>
    <nav id="toc"><p style="text-align: center"><strong>MANUAL</strong></p>
<ol style="margin: 0 auto; max-width: 350px">
<li><a href="../README.html">Introduction</a></li>
<li><a href="../docs/getting_started.html">Getting Started</a></li>
<li><a href="../docs/structure.html">Project Structure</a></li>
<li><a href="../docs/references.html">Cross Referencing</a></li>
<li><a href="../docs/config.html">Configuration</a></li>
<li><a href="../docs/templates.html">Templates</a></li>
<li><a href="../docs/sources.html">Source Types</a></li>
<li><a href="../docs/syntax.html">Markdown Syntax</a></li>
</ol>
<p style="text-align: center"><strong>Examples</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="../examples/basics.html">Basics</a></li>
</ul>
<p style="text-align: center"><a href="../docstrings.html"><strong>LIBRARY INDEX</strong></a></p>
<p style="text-align: center"><strong>SOURCE</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="Publish.html">Publish.jl</a></li>
<li><a href="files.html">files.jl</a></li>
<li><a href="projects.html">projects.jl</a></li>
<li><a href="targets.html">targets.jl</a></li>
<li><a href="docstrings.html">docstrings.jl</a></li>
<li><a href="tools.html">tools.jl</a></li>
</ul>
<p style="text-align: center"><a href="../LICENSE.html"><strong>LICENSE</strong></a></p>
</nav>
    <footer>
        Build with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language.</a>
    </footer>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
