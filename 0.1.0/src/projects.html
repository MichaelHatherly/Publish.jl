<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="documentation" />
    <title>Publish.jl</title>
    <link rel="stylesheet" href="..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;publish.css" />
    <link rel="stylesheet" href="..&#x2F;default.min.css" />
    <script src="..&#x2F;versions.js"></script>
    <script src="..&#x2F;lunr.js"></script>
    <script src="..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;publish.js"></script>
    
</head>
<body>
    <div class="menu">
        <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        <input id="search-input" placeholder="Search">
        <select id="version-selector"></select>
    </div>
    <main id="page"><article><h1 id="project-related-definitions"><a href="#project-related-definitions" class="anchor"></a>Project-related Definitions</h1>
<p>A collection of different globals related to default template files and other
assets.</p>
<pre><code class="language-julia">const TEMPLATE_DIR = joinpath(@__DIR__, &quot;templates&quot;)
const DEFAULT_TEMPLATES = Dict(
    &quot;html&quot;  =&gt; joinpath(TEMPLATE_DIR, &quot;html.mustache&quot;),
    &quot;latex&quot; =&gt; joinpath(TEMPLATE_DIR, &quot;latex.mustache&quot;),
)
const DEFAULT_CSS = [joinpath(TEMPLATE_DIR, f) for f in [&quot;normalize.css&quot;, &quot;tabulator_simple.min.css&quot;, &quot;publish.css&quot;, &quot;default.min.css&quot;]]
const DEFAULT_ASSETS = Dict(
    &quot;default_css&quot; =&gt; DEFAULT_CSS,
    &quot;default_js&quot;  =&gt; [
        joinpath(@__DIR__, &quot;templates&quot;, &quot;versions.js&quot;),
        joinpath(@__DIR__, &quot;templates&quot;, &quot;lunr.js&quot;),
        joinpath(@__DIR__, &quot;templates&quot;, &quot;highlight.min.js&quot;),
        joinpath(@__DIR__, &quot;templates&quot;, &quot;tabulator.min.js&quot;),
        joinpath(@__DIR__, &quot;templates&quot;, &quot;julia.min.js&quot;),
        joinpath(@__DIR__, &quot;templates&quot;, &quot;julia-repl.min.js&quot;),
        joinpath(@__DIR__, &quot;templates&quot;, &quot;publish.js&quot;),
    ],
)
const DEFAULT_ASSETS_SET = Set(Iterators.flatten(values(DEFAULT_ASSETS)))
</code></pre>
<p>The default contents of a <code>[publish]</code> section in a <code>Project.toml</code> file.</p>
<pre><code class="language-julia">project_defaults() = Dict(
    &quot;name&quot; =&gt; &quot;README&quot;,
    &quot;deps&quot; =&gt; Dict{String,String}(),
    &quot;publish&quot; =&gt; Dict(
        &quot;toc&quot; =&gt; &quot;toc.md&quot;,
        &quot;pages&quot; =&gt; [&quot;README.md&quot;],
        &quot;extra&quot; =&gt; [],
        &quot;template-engine&quot; =&gt; Mustache.render,
        &quot;html&quot; =&gt; Dict(
            &quot;paths&quot; =&gt; &quot;normal&quot;,
            &quot;default_js&quot; =&gt; DEFAULT_ASSETS[&quot;default_js&quot;],
            &quot;default_css&quot; =&gt; DEFAULT_ASSETS[&quot;default_css&quot;],
            &quot;template&quot; =&gt; Dict(&quot;file&quot; =&gt; DEFAULT_TEMPLATES[&quot;html&quot;]),
        ),
        &quot;latex&quot; =&gt; Dict(
            &quot;template&quot; =&gt; Dict(&quot;file&quot; =&gt; DEFAULT_TEMPLATES[&quot;latex&quot;]),
            &quot;documentclass&quot; =&gt; &quot;scrartcl&quot;,
        ),
    ),
)
</code></pre>
<p>The <a href="../docstrings/Publish.Project.html"><code>Project</code></a> struct itself, which holds all the data related to how to
build it and all it’s file dependencies.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    struct Project

Holds all the data needed to represent a `Publish` &quot;project&quot;.

`Project` objects can be constructed by either providing a `Module` or a
`Project.toml` file.
&quot;&quot;&quot;
Base.@kwdef struct Project
    project   :: File
    parent    :: Union{Nothing,Project}   = nothing
    pages     :: OrderedDict{String,File} = OrderedDict{String,File}()
    docs      :: OrderedDict{String,File} = OrderedDict{String,File}()
    resources :: Dict{String,File}        = Dict{String,File}()
    extra     :: Dict{String,Project}     = Dict{String,Project}()
    deps      :: Dict{String,Project}     = Dict{String,Project}()
    env       :: Dict{String,Any}         = Dict{String,Any}()
    globals   :: Dict{String,Any}         = Dict{String,Any}()
    mods      :: Set{Module}              = Set{Module}()
    loaded    :: Dict{String,Project}     = Dict{String,Project}()
end

Base.show(io::IO, project::Project) = print(io, &quot;$Project($(project.project))&quot;)
</code></pre>
<p>The main constructor for <a href="../docstrings/Publish.Project.html"><code>Project</code></a> objects.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    Project(path, [loaded, parent]; [globals])

A constructor for [`Project`](#) structs. Takes a `path` representing a
`Project.toml` file. Optional arguments `loaded` and `parent` are for internal
use only.
&quot;&quot;&quot;
function Project(
    path::AbstractString,
    loaded=Dict{String,Project}(),
    parent=nothing;
    globals=Dict{String,Any}()
)
    path = isdir(path) ? joinpath(path, &quot;Project.toml&quot;) : path
    path = isfile(path) ? abspath(path) : error(&quot;unknown project file '$path'.&quot;)
    path = realpath(path) # Normalise symlinked paths, to handle standard libs.
    # If we have already created this project then just return it, avoids recursive deps.
    haskey(loaded, path) &amp;&amp; return loaded[path]
    # Drop into the directory containing the project file.
    cd(dirname(path)) do
        # Load the project configuration.
        project_file = File(path)
        env = CommonMark.recursive_merge(project_defaults(), project_file.dict, globals)
        publish = env[&quot;publish&quot;]
        # Create a table-of-contents. Either from a toc.md file or a list of
        # markdown pages listed in the [publish] section of the Project.toml.
        toc_file =
            if isfile(publish[&quot;toc&quot;])
                File(abspath(publish[&quot;toc&quot;]))
            else
                io = IOBuffer()
                for page in filter(isfile, publish[&quot;pages&quot;])
                    _, file = splitdir(page)
                    name, _ = splitext(file)
                    println(io, &quot;  - [$name]($page)&quot;)
                end
                File(
                    mime = MIMETYPES[&quot;.md&quot;],
                    node = load_markdown(io)
                )
            end
        # Load all of the files referenced in the table-of-contents.
        pages = loadpages(toc_file)
        # Modules visible from the current project.
        mods = visible_modules(env)
        # Create and cache the project.
        project = loaded[path] = Project(
            project = project_file,
            parent  = parent,
            pages   = pages,
            mods    = mods,
            env     = env,
            globals = globals,
            loaded  = loaded,
        )
        # Register project resources. Ignores virtual resources.
        tryset!(project.resources, toc_file.name, toc_file)
        project.env[&quot;_toc&quot;] = toc_file
        register_resources!(project.resources, publish)
        # The following must happen after creation of the project since they reference it:
        # Extra internal projects.
        extra = Dict(abspath(f) =&gt; Project(f, loaded, project; globals=globals) for f in publish[&quot;extra&quot;])
        merge!(project.extra, extra)
        # Add available docstrings.
        merge!(project.docs, docstrings(project))
        # Package dependencies.
        for (name, uuid) in env[&quot;deps&quot;]
            file = find_project(uuid, name)
            if is_valid_project(file)
                project.deps[file] = Project(file, loaded; globals=globals)
            end
        end
        return project
    end
end

&quot;&quot;&quot;
    register_resources!(resources, env)

A helper function for use in `Project` that finds all files referenced in the
`[publish.html]` and `[publish.latex]` sections of a `Project.toml` and adds
them to the `.resources` list in a [`Project`](#).
&quot;&quot;&quot;
function register_resources!(resources, env::AbstractDict)
    function reg!(resources, path::AbstractString)
        if isfile(path)
            _, ext = splitext(path)
            if haskey(MIMETYPES, ext)
                file = File(abspath(path))
                tryset!(resources, file.name, file)
            end
        end
        return
    end
    reg!(resources, dict::AbstractDict) = foreach(v -&gt; reg!(resources, v), values(dict))
    reg!(resources, vector::Vector) = foreach(v -&gt; reg!(resources, v), vector)
    reg!(resources, other) = nothing
    for fmt in (&quot;html&quot;, &quot;latex&quot;)
        if haskey(env, fmt)
            reg!(resources, env[fmt])
        end
    end
end

_env_project_file(path::AbstractString) = Base.env_project_file(path)
_env_project_file(other) = nothing
</code></pre>
<p>A constructor for <a href="../docstrings/Publish.Project.html"><code>Project</code></a> objects that takes a <code>Module</code> as it’s input source.</p>
<pre><code class="language-julia">Project(mod::Module; kws...) = Project(_env_project_file(Base.pkgdir(mod)); kws...)

&quot;&quot;&quot;
    update!(project, file)

Removes the cached project and then rebuilds it to a new project and moves it's
content over to the old project.
&quot;&quot;&quot;
function update!(p::Project, file::AbstractString)
    # TODO: Make more efficient. Currently everything is rebuilt instead of
    # taking the changed `file` into account.
    new_p = p
    try
        _ = isfile(file) ? abspath(file) : error(&quot;not a file '$file'.&quot;)
        path = p.project.name
        delete!(p.loaded, path)
        new_p = Project(path, p.loaded, p.parent; globals=p.globals)
    catch err
        @error err
    finally
        p.loaded[p.project.name] = p
        move!(p, new_p)
    end
    return p
end

&quot;&quot;&quot;
    move!(to, from)

Transfers the data stored in `from::Project` to `to::Project`.
&quot;&quot;&quot;
function move!(to::Project, from::Project)
    replace!(to.project.dict, from.project.dict)
    replace!(to.pages, from.pages)
    replace!(to.docs, from.docs)
    replace!(to.resources, from.resources)
    replace!(to.extra, from.extra)
    replace!(to.deps, from.deps)
    replace!(to.env, from.env)
    replace!(to.globals, from.globals)
    replace!(to.mods, from.mods)
    return to
end
replace!(d::AbstractDict, ds::AbstractDict...) = (empty!(d); merge!(d, CommonMark.recursive_merge(ds...)))
replace!(s::AbstractSet, ss::AbstractSet...) = (empty!(s); union!(s, ss...))
</code></pre>
<h2 id="project-watching-related-functions"><a href="#project-watching-related-functions" class="anchor"></a>Project Watching-related functions.</h2>
<pre><code class="language-julia">files(p::Project) = Set{String}(IterTools.chain((p.project.name,), keys(p.resources), keys(p.pages)))
extra(p::Project) = Set{String}(keys(p.extra))

&quot;&quot;&quot;
    editable(p)

Returns the set of `Project`s that can be edited in relation to the initial
`Project`. This means the project itself, as well as an `publish.extra`
projects that are listed in the `Project.toml`.
&quot;&quot;&quot;
function editable(p::Project, out=Base.IdSet{Project}())
    if !(p in out)
        push!(out, p)
        for each in values(p.extra)
            editable(each, out)
        end
        editable(p.parent, out)
    end
    return out
end
editable(::Nothing, out=Base.IdSet{Project}()) = out

&quot;&quot;&quot;
    struct WatchedProject

An internal wrapper type that stores a `Project` object and watches for changes
to occur in any files that the `Project` makes use of. When any changes occur
the provided `actions` list is iterated over.
&quot;&quot;&quot;
struct WatchedProject
    p::Project
    dict::IdDict{Project,LiveServer.SimpleWatcher}
    dirs::IdDict{Function,String}

    function WatchedProject(p::Project, actions...)
        dirs = IdDict{Function,String}()
        fn = function (action)
            temp = get!(() -&gt; mktempdir(), dirs, action)
            (project, changed) -&gt; action(project, changed, temp)
        end
        new(p, watch(p, map(fn, actions)...), dirs)
    end
end

Base.show(io::IO, wp::WatchedProject) = print(io, &quot;$WatchedProject($(wp.p), ...)&quot;)

&quot;&quot;&quot;
    watch(p, actions...)

Watch a `p::Project` for changes and run all `actions...` when any changes
occur.
&quot;&quot;&quot;
function watch(p::Project, actions...; dict=IdDict{Project,LiveServer.SimpleWatcher}())
    # We only setup a watcher if the project it's already being watched.
    if !haskey(dict, p)
        # Watch the project and any 'extra' projects that it references.
        sw = watch_files(p, get!(() -&gt; LiveServer.SimpleWatcher(), dict, p))
        for each in values(p.extra)
            watch(each; dict=dict)
        end
        # The callback function that gets called whenever we notice a change in
        # the current project.
        callback = function (path)
            @info &quot;$p =&gt; $path&quot; # TODO: use loggin package.
            # Hook into Revise for code reloading.
            revise(p)
            # We've had a change within project so update it.
            update!(p, path)
            # Re-watch this project to pick up new files to watch.
            watch_files(p, sw)
            # Also re-watch it's 'extra' projects.
            for each in values(p.extra)
                watch(each; dict=dict)
            end
            # There may be projects that aren't in 'extra' any more. Stop
            # watching them to avoid updating things that we don't need to.
            for each in setdiff(Base.IdSet{Project}(keys(dict)), editable(p))
                LiveServer.stop(dict[each]) # Stop it's watcher.
                delete!(dict, each) # And remove it from the cache.
            end
            # Run user-provided actions after each update.
            for each in actions
                each(p, path)
            end
        end
        LiveServer.set_callback!(sw, callback)
        LiveServer.start(sw)
    end
    return dict
end

function watch_files(p::Project, sw::LiveServer.SimpleWatcher)
    empty!(sw.watchedfiles) # TODO: proper API for this?
    for file in files(p)
        LiveServer.is_watched(sw, file) || LiveServer.watch_file!(sw, file)
    end
    return sw
end

stop(ws::WatchedProject) = foreach(LiveServer.stop, values(ws.dict))
start(ws::WatchedProject) = foreach(LiveServer.start, values(ws.dict))
</code></pre>
<p>A section of helper functions for the code found above.</p>
<pre><code class="language-julia">function loadpages(::Nothing, toc::File)
    pages = OrderedDict{String,File}()
    for page in pageorder(toc)
        page = abspath(page)
        pages[page] = File(page)
    end
    return pages
end
loadpages(toc::File) = loadpages(toc.name, toc)
loadpages(path::AbstractString, toc::File) = cd(() -&gt; loadpages(nothing, toc), dirname(path))

function pageorder(ast::CommonMark.Node)
    pages = String[]
    for (node, enter) in ast
        if enter &amp;&amp; node.t isa CommonMark.Link
            if isfile(node.t.destination)
                push!(pages, node.t.destination)
            end
        end
    end
    return pages
end
pageorder(toc::File) = pageorder(toc.node)
pageorder(::Nothing) = String[]

function find_project(pkgid::Base.PkgId)
    haskey(Base.loaded_modules, pkgid) || Base.require(pkgid)
    mod = Base.loaded_modules[pkgid]
    return _env_project_file(Base.pkgdir(mod))
end
find_project(uuid, name) = find_project(Base.PkgId(Base.UUID(uuid), name))

is_valid_project(path::AbstractString) = true
is_valid_project(other) = false

&quot;&quot;&quot;
    visible_modules(env)

What modules are available from the given project environment `env`.
&quot;&quot;&quot;
function visible_modules(env::AbstractDict)
    mod = project_to_module(env)
    return mod === nothing ? Set{Module}() : modules(mod)
end

&quot;&quot;&quot;
    project_to_module(env)

Find the top-level module associated with a given project environment `env`.
&quot;&quot;&quot;
function project_to_module(env::AbstractDict)
    if haskey(env, &quot;uuid&quot;) &amp;&amp; haskey(env, &quot;name&quot;)
        pkgid = Base.PkgId(Base.UUID(env[&quot;uuid&quot;]), env[&quot;name&quot;])
        haskey(Base.loaded_modules, pkgid) || Base.require(pkgid)
        return Base.loaded_modules[pkgid]
    else
        return nothing
    end
end
</code></pre>
<p>Modules that should be ignored when finding which modules a <a href="../docstrings/Publish.Project.html"><code>Project</code></a>
depends on.</p>
<pre><code class="language-julia">const IGNORE_LIST = (Main, Base.__toplevel__, Base.MainInclude)

&quot;&quot;&quot;
    modules(root)

A `Set` of all modules reachable from the given `root` `Module`. This includes
un-exported and imported `Module`s.
&quot;&quot;&quot;
modules(root::Module) = union!(modules(root, Set{Module}()), DEFAULT_MODULES)
function modules(root::Module, mods::Set{Module})
    for name in names(root; all=true, imported=true)
        if !Base.isdeprecated(root, name) &amp;&amp; isdefined(root, name) &amp;&amp; ismodule(root, name)::Bool
            mod = convert(Module, getfield(root, name))
            if !(mod in mods) &amp;&amp; !(mod in IGNORE_LIST)
                push!(mods, mod)
                modules(mod, mods)
            end
        end
    end
    return mods
end
@noinline ismodule(m::Module, s::Symbol) = getfield(m, s)::Any isa Module

&quot;&quot;&quot;
    DEFAULT_MODULES::Set{Module}

The set of modules that every package has access to.
&quot;&quot;&quot;
const DEFAULT_MODULES = modules(Core, modules(Base, Set{Module}()))

&quot;&quot;&quot;
    tryset!(dict, key, value) -&gt; Bool

Try to add the given `key`/`value` pair to the object `dict`. Returns `true`
or `false` depending on whether the action was successful.
&quot;&quot;&quot;
function tryset! end

tryset!(dict::AbstractDict{K}, key::K, value) where K = (dict[key] = value; true)
tryset!(dict, key, value) = false

&quot;&quot;&quot;
    revise(p)

If `Revise` has been loaded into the current session then run `Revise.revise` to
pick up any changes within out project's docstrings.
&quot;&quot;&quot;
function revise(p::Project)
    id = Base.PkgId(Base.UUID(&quot;295af30f-e4ad-537b-8983-00126c2a3abe&quot;), &quot;Revise&quot;)
    if haskey(Base.loaded_modules, id)
        Revise = Base.loaded_modules[id]
        try
            Revise.revise()
        catch err
            @error err
        end
    end
    return
end
</code></pre>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="files.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="targets.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
    </main>
    <nav id="toc"><p style="text-align: center"><strong>MANUAL</strong></p>
<ol style="margin: 0 auto; max-width: 350px">
<li><a href="../README.html">Introduction</a></li>
<li><a href="../docs/getting_started.html">Getting Started</a></li>
<li><a href="../docs/structure.html">Project Structure</a></li>
<li><a href="../docs/references.html">Cross Referencing</a></li>
<li><a href="../docs/config.html">Configuration</a></li>
<li><a href="../docs/templates.html">Templates</a></li>
<li><a href="../docs/sources.html">Source Types</a></li>
<li><a href="../docs/syntax.html">Markdown Syntax</a></li>
</ol>
<p style="text-align: center"><strong>Examples</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="../examples/basics.html">Basics</a></li>
</ul>
<p style="text-align: center"><a href="../docstrings.html"><strong>LIBRARY INDEX</strong></a></p>
<p style="text-align: center"><strong>SOURCE</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="Publish.html">Publish.jl</a></li>
<li><a href="files.html">files.jl</a></li>
<li><a href="projects.html">projects.jl</a></li>
<li><a href="targets.html">targets.jl</a></li>
<li><a href="docstrings.html">docstrings.jl</a></li>
<li><a href="tools.html">tools.jl</a></li>
</ul>
<p style="text-align: center"><a href="../LICENSE.html"><strong>LICENSE</strong></a></p>
</nav>
    <footer>
        Build with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language.</a>
    </footer>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
