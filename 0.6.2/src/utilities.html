<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="documentation" />
    <title>Publish.jl</title>
    <link rel="stylesheet" href="..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;publish.css" />
    <link rel="stylesheet" href="..&#x2F;default.min.css" />
    <script src="..&#x2F;versions.js"></script>
    <script src="..&#x2F;lunr.js"></script>
    <script src="..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;publish.js"></script>
    
</head>
<body>
    <div class="menu">
        <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        <input id="search-input" placeholder="Search">
        <select id="version-selector"></select>
    </div>
    <main id="page"><article><h1 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h1>
<pre><code class="language-julia">&quot;&quot;&quot;
    sandbox(f, path)

Evaluate the function `f` in the given folder given by `path`. When `path`
does not exist it is created first.
&quot;&quot;&quot;
function sandbox end

sandbox(f, ::Nothing) = mktempdir(dir -&gt; cd(f, dir))
sandbox(f, temp::AbstractString) = isdir(temp) ? cd(f, temp) : (mkpath(temp); cd(f, temp))

&quot;&quot;&quot;
    init_markdown_parser()

Returns a new `CommonMark.Parser` object with all extensions enabled.
&quot;&quot;&quot;
function init_markdown_parser(env=Dict())
    cm = CommonMark
    imports = get(() -&gt; Module[], env, &quot;cell-imports&quot;)
    return cm.enable!(cm.Parser(), [
        # CommonMark-provided.
        cm.AdmonitionRule(),
        cm.AttributeRule(),
        cm.AutoIdentifierRule(),
        cm.CitationRule(),
        cm.DollarMathRule(),
        cm.FootnoteRule(),
        cm.FrontMatterRule(toml=TOML.parse),
        cm.MathRule(),
        cm.RawContentRule(),
        cm.TableRule(),
        cm.TypographyRule(),
        # Publish-provided.
        CellRule(imports = imports),
    ])
end

load_markdown(io::IO, parser=init_markdown_parser()) = parser(seekstart(io))
load_markdown(str::AbstractString, parser=init_markdown_parser()) = load_markdown(IOBuffer(str), parser)

function visible_modules(env::AbstractDict)
    roots = env[&quot;publish&quot;][&quot;modules&quot;]
    if isempty(roots)
        mod = findmodule(env)
        return mod === nothing ? Set{Module}() : modules(mod)
    else
        set = Set{Module}()
        for root in roots
            bind = binding(root)
            if Docs.defined(bind)
                modules(Docs.resolve(bind), set)
            else
                @warn &quot;module '$root' listed in 'publish.modules' does not exist.&quot;
            end
        end
        return set
    end
end

&quot;&quot;&quot;
Modules to ignore when searching for available modules.
&quot;&quot;&quot;
const IGNORE_LIST = (Main, Base.__toplevel__, Base.MainInclude)

&quot;&quot;&quot;
    modules(root)

Returns the set of modules visible from the given `root` module.
&quot;&quot;&quot;
modules(root::Module) = union!(modules(root, Set{Module}()), DEFAULT_MODULES)
function modules(root::Module, mods::Set{Module})
    for name in names(root; all=true, imported=true)
        if !Base.isdeprecated(root, name) &amp;&amp; isdefined(root, name) &amp;&amp; ismodule(root, name)::Bool
            mod = convert(Module, getfield(root, name))
            if !(mod in mods) &amp;&amp; !(mod in IGNORE_LIST)
                push!(mods, mod)
                modules(mod, mods)
            end
        end
    end
    return mods
end
@noinline ismodule(m::Module, s::Symbol) = getfield(m, s)::Any isa Module

&quot;&quot;&quot;
The set of modules available to all packages.
&quot;&quot;&quot;
const DEFAULT_MODULES = modules(Core, modules(Base, Set{Module}()))

&quot;&quot;&quot;
    categorise(binding)

Returns the category of a given `Docs.Binding` object `binding`. These
categories are used for displaying details about docstrings.
&quot;&quot;&quot;
function categorise(binding)
    ismacro(binding) = startswith(string(binding.var), '@')
    category(other)         = isconst(binding.mod, binding.var) ? &quot;constant&quot; : &quot;global&quot;
    category(obj::Module)   = &quot;module&quot;
    category(obj::DataType) = isconcretetype(obj) ? &quot;struct&quot; : &quot;type&quot;
    category(obj::UnionAll) = isconcretetype(obj) ? &quot;parametric struct&quot; : &quot;parametric type&quot;
    category(obj::Function) = ismacro(binding) ? &quot;macro&quot; : &quot;function&quot;
    return Docs.defined(binding) ? category(Docs.resolve(binding)) : &quot;undefined&quot;
end

&quot;&quot;&quot;
Returns the `Docs.Binding` object given an expression or string.
&quot;&quot;&quot;
function binding end

function binding(mod::Module, expr::Expr)
    if Meta.isexpr(expr, :.)
        parent = binding(mod, expr.args[1])
        if Docs.defined(parent)
            return binding(Docs.resolve(parent), expr.args[2:end]...)
        end
    end
    return Docs.Binding(mod, nameof(mod))
end
binding(mod::Module, str::AbstractString) = binding(mod, Meta.parse(str; raise=false))
binding(mod::Module, symbol::Symbol) = Docs.Binding(mod, symbol)
binding(mod::Module, quot::QuoteNode) = Docs.Binding(mod, quot.value)
binding(mod, other...) = Docs.Binding(mod, nameof(mod))
binding(str::AbstractString) = binding(Main, str)
binding(mod::Module) = binding(mod, nameof(mod))

function printdoc(io::IO, docstr)
    for part in docstr.text
        Docs.formatdoc(io, docstr, part)
    end
    return io
end

&quot;&quot;&quot;
    rmerge(ds...)

Recursively merge the `Dict`s provided in `ds`. Last argument wins when
conflicts occur.
&quot;&quot;&quot;
rmerge(ds::AbstractDict...) = merge(rmerge, ds...)
rmerge(args...) = last(args)

function try_touch(default::Function, f::FileTree, idx)
    try
        f[idx][]
    catch err
        f = touch(f, idx; value=default())
    end
    return f
end

const IGNORE_PATHS = r&quot;^[^\.\_]&quot;
const CODE_FENCE = '~'^10

function page_neighbours(pages::AbstractVector)
    flat = Iterators.flatten((Ref(first(pages)), pages, Ref(last(pages))))
    part = IterTools.partition(flat, 3, 1)
    return Dict(x =&gt; (prev=p, next=n) for (p, x, n) in part)
end

&quot;&quot;&quot;
    with_extension(path, ext)

Return a path with the extension set to `ext`.
&quot;&quot;&quot;
function with_extension end

with_extension(p::AbstractString, ext) = &quot;$(first(splitext(p))).$ext&quot;
with_extension(p::AbstractPath, ext) = with_extension(string(p), ext)

&quot;&quot;&quot;
    relative_paths(func, project, file)

Rewrite any file paths within a [`Project`](#)'s `.env` to be relative to the
given `file` and pass then to the `func` argument for evaluation.
&quot;&quot;&quot;
function relative_paths(func, p::Project, file::AbstractString)
    # Configuration replacement walker functions.
    with_replacement(f, v) = v
    with_replacement(f, v::Union{AbstractString,AbstractPath}) = f(v)
    with_replacement(f, xs::Vector{T}) where T = T[with_replacement(f, x) for x in xs]
    with_replacement(f, dict::T) where T &lt;: AbstractDict = T(k =&gt; with_replacement(f, v) for (k, v) in dict)
    # Rewrite configuration paths.
    pub′ = with_replacement(p.env[&quot;publish&quot;]) do value
        hasfile(p.tree, value) ? relpath(string(value), dirname(joinpath(&quot;.&quot;, file))) : value
    end
    return func(pub′)
end
relative_paths(f, p::Project, path::AbstractPath) = relative_paths(f, p, string(path))

&quot;&quot;&quot;
    revise(project)

When Revise.jl is loaded in the current session trigger `Revise.revise`.
&quot;&quot;&quot;
revise(project) = nothing

function hasfile(tree::FileTree, path)
    # TODO: needs real API here.
    try
        tree[path]
    catch err
        return false
    end
    return true
end

&quot;&quot;&quot;
    frontmatter(ast)

Returns a `Dict` containing the front matter content of a markdown `ast`. When
no front matter is found then an empty `Dict` is returned.
&quot;&quot;&quot;
function frontmatter(ast::CommonMark.Node)
    CommonMark.isnull(ast.first_child)           &amp;&amp; return Dict{String,Any}()
    ast.first_child.t isa CommonMark.FrontMatter &amp;&amp; return ast.first_child.t.data
    return Dict{String,Any}()
end

# Needed by latex engine since it doesn't like windows paths.
if Sys.iswindows()
    unix_style_path(path) = unix_joinpath(splitpath(path)...)
else
    unix_style_path(path) = path
end
function unix_joinpath(path::AbstractString, paths::AbstractString...)::String
    for p in paths
        if isabspath(p)
            path = p
        elseif isempty(path) || path[end] == '/'
            path *= p
        else
            path *= &quot;/&quot; * p
        end
    end
    return path
end
unix_joinpath(path::AbstractString) = path
</code></pre>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="tools.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="..&#x2F;LICENSE.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
    </main>
    <nav id="toc"><p style="text-align: center"><strong>MANUAL</strong></p>
<ol style="margin: 0 auto; max-width: 350px">
<li><a href="../README.html">Introduction</a></li>
<li><a href="../docs/getting_started.html">Getting Started</a></li>
<li><a href="../docs/structure.html">Project Structure</a></li>
<li><a href="../docs/references.html">Cross Referencing</a></li>
<li><a href="../docs/config.html">Configuration</a></li>
<li><a href="../docs/templates.html">Templates</a></li>
<li><a href="../docs/themes.html">Custom Themes</a></li>
<li><a href="../docs/sources.html">Source Types</a></li>
<li><a href="../docs/cells.html">Executable “Cells”</a></li>
<li><a href="../docs/syntax.html">Markdown Syntax</a></li>
</ol>
<p style="text-align: center"><strong>Examples</strong></p>
<ul style="list-style: none; margin: 0 auto; max-width: 350px">
<li><a href="../examples/basics.html">Basics</a></li>
<li><a href="../examples/cells.html">Cells</a></li>
</ul>
<p style="text-align: center"><a href="../docstrings.html"><strong>LIBRARY INDEX</strong></a></p>
<p style="text-align: center"><strong>SOURCE</strong></p>
<ul style="margin: 0 auto; max-width: 350px">
<li><a href="../src/Publish.html"><code>Publish.jl</code></a></li>
<li><a href="../src/projects.html"><code>projects.jl</code></a></li>
<li><a href="../src/themes.html"><code>themes.jl</code></a></li>
<li><a href="../src/load.html"><code>load.jl</code></a></li>
<li><a href="../src/cells.html"><code>cells.jl</code></a></li>
<li><a href="../src/save.html"><code>save.jl</code></a></li>
<li><a href="../src/serve.html"><code>serve.jl</code></a></li>
<li><a href="../src/deploy.html"><code>deploy.jl</code></a></li>
<li><a href="../src/tools.html"><code>tools.jl</code></a></li>
<li><a href="../src/utilities.html"><code>utilities.jl</code></a></li>
</ul>
<p style="text-align: center"><a href="../LICENSE.html"><strong>LICENSE</strong></a></p>
</nav>
    <footer>
        Built with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language.</a>
    </footer>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
